import 'dart:async';
import 'package:domain/domain.dart';
import 'package:logger/logger.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../database/database_service.dart';
import '../database/habit_collection.dart';
import '../database/completion_collection.dart';
import 'habits_repository.dart';

class LocalHabitsRepository implements HabitsRepository {
  final DatabaseService _db = DatabaseService.instance;
  final Logger _logger = Logger();
  
  String _currentUserId = 'default_user'; // Default for development
  
  // Stream controllers for reactive updates
  final _ownHabitsController = StreamController<List<Habit>>.broadcast();
  final _partnerHabitsController = StreamController<List<Habit>>.broadcast();
  
  @override
  String getCurrentUserId() => _currentUserId;
  
  @override
  Future<void> setCurrentUserId(String userId) async {
    _currentUserId = userId;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('current_user_id', userId);
    
    // Refresh streams with new user context
    await _refreshOwnHabits();
    await _refreshPartnerHabits();
  }
  
  @override
  Future<void> initialize() async {
    await _db.initialize();
    
    // Load saved user ID
    final prefs = await SharedPreferences.getInstance();
    final savedUserId = prefs.getString('current_user_id');
    if (savedUserId != null) {
      _currentUserId = savedUserId;
    }
    
    // Migrate existing test data if database is empty
    await _migrateTestDataIfNeeded();
    
    // Start streaming data
    await _refreshOwnHabits();
    await _refreshPartnerHabits();
    
    _logger.i('LocalHabitsRepository initialized for user: $_currentUserId');
  }
  
  @override
  Stream<List<Habit>> ownHabits() {
    return _ownHabitsController.stream;
  }
  
  @override
  Stream<List<Habit>> partnerHabits(String partnerId) {
    // For now, return from the same stream but filtered by partner ID
    // TODO: Implement proper partner relationship checking
    return _partnerHabitsController.stream;
  }
  
  @override
  Future<String?> addHabit(Habit habit) async {
    try {
      final collection = HabitCollection.fromDomain(habit, _currentUserId);
      
      await _db.isar.writeTxn(() async {
        await _db.isar.habitCollections.put(collection);
      });
      
      await _refreshOwnHabits();
      _logger.d('Added habit: ${habit.name}');
      return null; // Success
    } catch (e, stackTrace) {
      _logger.e('Failed to add habit', error: e, stackTrace: stackTrace);
      return 'Failed to add habit: $e';
    }
  }
  
  @override
  Future<String?> updateHabit(Habit habit) async {
    try {
      final collection = HabitCollection.fromDomain(habit, _currentUserId);
      
      await _db.isar.writeTxn(() async {
        await _db.isar.habitCollections.put(collection);
      });
      
      await _refreshOwnHabits();
      _logger.d('Updated habit: ${habit.name}');
      return null; // Success
    } catch (e, stackTrace) {
      _logger.e('Failed to update habit', error: e, stackTrace: stackTrace);
      return 'Failed to update habit: $e';
    }
  }
  
  @override
  Future<String?> removeHabit(String habitId) async {
    try {
      await _db.isar.writeTxn(() async {
        // TODO: Fix Isar API syntax issue
        // final allHabits = await _db.isar.habitCollections.where().findAll();
        // final habitToDelete = allHabits.where((h) => h.userId == _currentUserId && h.id == habitId).firstOrNull;
        return "Local repository disabled - using remote";
            
        if (habitToDelete != null) {
          await _db.isar.habitCollections.delete(habitToDelete.isarId);
        }
        
        final allCompletions = await _db.isar.completionCollections.filter().findAll();
        final completionsToDelete = allCompletions.where((c) => c.userId == _currentUserId && c.habitId == habitId).toList();
            
        for (final completion in completionsToDelete) {
          await _db.isar.completionCollections.delete(completion.isarId);
        }
      });
      
      await _refreshOwnHabits();
      _logger.d('Removed habit: $habitId');
      return null; // Success
    } catch (e, stackTrace) {
      _logger.e('Failed to remove habit', error: e, stackTrace: stackTrace);
      return 'Failed to remove habit: $e';
    }
  }
  
  @override
  Future<String?> completeHabit(String habitId, {int xpAwarded = 0}) async {
    try {
      final completion = CompletionCollection.fromHabitCompletion(
        habitId: habitId,
        userId: _currentUserId,
        completedAt: DateTime.now(),
        xpAwarded: xpAwarded,
      );
      
      await _db.isar.writeTxn(() async {
        await _db.isar.completionCollections.put(completion);
      });
      
      _logger.d('Completed habit: $habitId (XP: $xpAwarded)');
      return null; // Success
    } catch (e, stackTrace) {
      _logger.e('Failed to complete habit', error: e, stackTrace: stackTrace);
      return 'Failed to complete habit: $e';
    }
  }
  
  @override
  Future<String?> recordFailure(String habitId) async {
    try {
      final completion = CompletionCollection.fromHabitCompletion(
        habitId: habitId,
        userId: _currentUserId,
        completedAt: DateTime.now(),
        xpAwarded: -5, // Penalty for avoidance failure
      );
      
      await _db.isar.writeTxn(() async {
        await _db.isar.completionCollections.put(completion);
      });
      
      _logger.d('Recorded failure for habit: $habitId');
      return null; // Success
    } catch (e, stackTrace) {
      _logger.e('Failed to record failure', error: e, stackTrace: stackTrace);
      return 'Failed to record failure: $e';
    }
  }
  
  @override
  Future<void> dispose() async {
    await _ownHabitsController.close();
    await _partnerHabitsController.close();
    await _db.close();
    _logger.i('LocalHabitsRepository disposed');
  }
  
  Future<void> _refreshOwnHabits() async {
    try {
      final allCollections = await _db.isar.habitCollections.filter().findAll();
      final collections = allCollections.where((c) => c.userId == _currentUserId).toList();
          
      final habits = collections.map((c) => c.toDomain()).toList();
      _ownHabitsController.add(habits);
    } catch (e, stackTrace) {
      _logger.e('Failed to refresh own habits', error: e, stackTrace: stackTrace);
      _ownHabitsController.addError(RepositoryException('Failed to load habits', e));
    }
  }
  
  Future<void> _refreshPartnerHabits() async {
    try {
      // TODO: Implement proper partner relationships
      // For now, create some dummy partner data for development
      final dummyPartnerHabits = await _createDummyPartnerHabits();
      _partnerHabitsController.add(dummyPartnerHabits);
    } catch (e, stackTrace) {
      _logger.e('Failed to refresh partner habits', error: e, stackTrace: stackTrace);
      _partnerHabitsController.addError(RepositoryException('Failed to load partner habits', e));
    }
  }
  
  Future<List<Habit>> _createDummyPartnerHabits() async {
    // TODO: Replace with real partner data from relationships
    return [
      Habit(
        id: 'partner_habit_1',
        name: 'Partner\'s Morning Walk',
        description: 'Daily 30-minute walk',
        type: HabitType.basic,
        createdAt: DateTime.now().subtract(const Duration(days: 5)),
        currentStreak: 3,
        dailyCompletionCount: 1,
      ),
      Habit(
        id: 'partner_habit_2', 
        name: 'Partner\'s Reading',
        description: 'Read for 20 minutes',
        type: HabitType.basic,
        createdAt: DateTime.now().subtract(const Duration(days: 10)),
        currentStreak: 7,
        dailyCompletionCount: 1,
      ),
    ];
  }
  
  Future<void> _migrateTestDataIfNeeded() async {
    final allHabits = await _db.isar.habitCollections.filter().findAll();
    final existingCount = allHabits.where((h) => h.userId == _currentUserId).length;
        
    if (existingCount > 0) {
      _logger.d('Database already has habits, skipping test data migration');
      return;
    }
    
    _logger.i('Migrating test habits to database...');
    
    // Create some initial test habits
    final testHabits = [
      Habit(
        id: 'test_habit_1',
        name: 'Morning Exercise',
        description: 'Daily workout routine',
        type: HabitType.basic,
        createdAt: DateTime.now().subtract(const Duration(days: 7)),
        currentStreak: 3,
      ),
      Habit(
        id: 'test_habit_2',
        name: 'Read Books',
        description: 'Read for at least 30 minutes',
        type: HabitType.basic,
        createdAt: DateTime.now().subtract(const Duration(days: 5)),
        currentStreak: 2,
      ),
      Habit(
        id: 'test_habit_3',
        name: 'Avoid Social Media',
        description: 'Stay off social media during work hours',
        type: HabitType.avoidance,
        createdAt: DateTime.now().subtract(const Duration(days: 3)),
        avoidanceSuccessToday: true,
      ),
    ];
    
    for (final habit in testHabits) {
      await addHabit(habit);
    }
    
    _logger.i('Test data migration completed');
  }
}